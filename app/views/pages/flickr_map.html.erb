<style>
.area {
  fill: url(#temperature-gradient);
  opacity:0.7;
  stroke-width: 1px;
}

.axis.y line,
.axis.y path{
  stroke: white;
  stroke-width: 2px;
}

.axis.y text {
  fill: white;
  text-shadow: 1px 1px 3px black;
  font-size: 18px;
}

.map-group {
  fill: white;
  stroke: black;
}

circle.photo {
  fill: red;
  opacity: 0.5;
  stroke: none;
}

</style>
<script>
  // let i = 1
  // gon.dates.forEach((date) => {
  //   console.log('old', date)
  // })

  // Create time series values
  const baseDate = Date.parse('2016-1-1 05:00')
  let timeSeriesDates = [baseDate.toString('yyyy-MM-dd HH:mm')]
  let i = 1
  while(i < 24) {
    newDate = baseDate.add(1).hour()
    timeSeriesDates.push(newDate.toString('yyyy-MM-dd HH:mm'))
    i += 1
  }


  const height = 120
  const width = window.innerHeight
  const margin = {left: 0, right: 0, top: 20, bottom: 20}

  // create scale for axis
  let y = d3.scaleLinear()
            .domain([0,d3.max(d3.values(gon.frequency_map))])
            .range([height,0]) // invert this so I don't have to subtract later

  const parseDate = d3.timeParse('%Y-%m-%d %H:%M') // creating a parser tool, puts dates in that format
  const hourFormat = d3.timeFormat("%-H")
  const hourOrder = timeSeriesDates.map((d) => parseInt(hourFormat(parseDate(d))))

  let x = d3.scaleTime()
            .domain(d3.extent(timeSeriesDates, (d) => parseDate(d))) // extent is a function that returns an array [min, max]
            .range([0, width]) // actual screen pixels

  const yAxisHeight = window.innerHeight - 40
  let yAxisScale = d3.scaleTime()
                  .domain(d3.extent(timeSeriesDates, (d) => parseDate(d))) // extent is a function that returns an array [min, max]
                  .range([0, yAxisHeight]) // actual screen pixels

  // create axis generator
  const yAxis = d3.axisRight(yAxisScale).ticks(24).tickFormat(d3.timeFormat("%-I %p"))

  // area generator
  const area = d3.area()
                .x((d,i) => x(parseDate(timeSeriesDates[i])))
                .y0(height)
                .y1((d,i) => y(gon.frequency_map[d]))
                .curve(d3.curveCardinal)


  // Drawing this shit, add the base SVG
  const svg = d3.select('body').append('svg')
              .attr('height', '100vh')
              .attr('width', '100%')
              .attr('class', 'black-gradient')



  // chart and axis will be grouped and positioned together
  let chartGroup = svg.append('g')
                      .attr('transform', `translate(${margin.left}, 0)`)

  chartGroup.append("linearGradient")
      .attr("id", "temperature-gradient")
      .attr("gradientUnits", "userSpaceOnUse")
      .attr("x1", 0).attr("y1", 0)
      .attr("x2", width).attr("y2", 0)
    .selectAll("stop")
      .data([
        {offset: "5%", color: "#550090"},
        {offset: "15%", color: "#e1de02"},
        {offset: "40%", color: "#f5f21d"},
        {offset: "55%", color: "#e1de02"},
        {offset: "68%", color: "#550090"}
      ])
    .enter().append("stop")
      .attr("offset", function(d) { return d.offset; })
      .attr("stop-color", function(d) { return d.color; })

  //console.log('frequency_map', gon.frequency_map)

  // Add the line from the area geneator
  chartGroup.append('path')
            .attr('d', area(hourOrder))
            .attr('transform', `translate(${height},0) rotate(90)`)
            .attr('class', 'area')

    // Add the yAxis
  svg.append('g') // axis are groups
            .attr('class', 'axis y')
            .attr('transform', `translate(5,${margin.top})`)
            .call(yAxis) // adding y axis to chart


   // Define Zoom Function Event Listener
  function zoomFunction() {
      d3.selectAll("path.geo")
          .attr("transform", d3.event.transform);
  }

  // Define Zoom Behavior
  const zoom = d3.zoom()
      .scaleExtent([0.2, 10])
      .on("zoom", zoomFunction);


  const drawMap = (error, geo, photos) => {
    const mapMaxWidth = 500
    const groupMarginLeft = 500

    // Map of manhattan container
    const mapGroup = svg.append('g')
                      .attr('transform', `translate(${height + margin.left}, 0)`)
                      .attr('class', 'map-group')

    const projection = d3.geoMercator()
                        .rotate([0, 0, 100])
                        .fitExtent([[0, margin.top], [mapMaxWidth, window.innerHeight - margin.top]], geo)


    const geoPath = d3.geoPath()
                    .projection(projection)

    // Drawing the map
    mapGroup.append('path')
              .attr('d', geoPath(geo))
              .attr('class', 'geo')
              .attr('transform', `translate(${groupMarginLeft}, 0)`)


    // Adding the circles
    let a = {lng: -73.968285, lat: 40.785091}
    let b = {lng: -74.004753, lat: 40.747964}
    let coor = projection([-73.968285, 40.785091])
    let gcoor = projection([b.lng, b.lat])
    mapGroup.selectAll('circle.photo')
            .data(photos.photos)
            .enter().append('circle')
                    .attr('cx', (d,i) => projection([d.lng, d.lat])[0])
                    .attr('cy', (d,i) => projection([d.lng, d.lat])[1])
                    .attr('r', 3)
                    .attr('class', 'photo')
                    .attr('transform', `translate(${groupMarginLeft}, 0)`)


    // console.log(' projection([73.9654, 40.7829])[0]',  projection([73.9654, 40.7829])[0])
    // console.log(' projection([73.9654, 40.7829])[1]',  projection([73.9654, 40.7829])[1])
    // // LNG FIRST, THEN LAT
    // //
    // let coor = projection([-73.968285, 40.785091])
    // mapGroup.append('circle')
    //                 .attr('cx', coor[0])
    //                 .attr('cy', coor[1])
    //                 .attr('r', 10)
    //                 .attr('class', 'city')
  }


  // Load the data
  d3.queue()
    .defer(d3.json, '/nyc/manhattan-outline.geojson')
    .defer(d3.json, '/nyc/new-york-photos-park.json')
    .await(drawMap)


</script>
